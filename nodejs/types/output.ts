// *** WARNING: this file was generated by pulumi-language-nodejs. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "../types/input";
import * as outputs from "../types/output";

import * as utilities from "../utilities";

export namespace schemas {
    /**
     * References the SKU used for this block. If a reference to the source image is used as the base for creating this block storage.
     */
    export interface BlockStorageSpec {
        /**
         * Size of the block storage in GB.
         */
        sizeGB: number;
        /**
         * Reference to the SKU of the block storage.
         */
        skuRef: outputs.schemas.Reference;
        /**
         * Reference to the source image used as the base for creating the block storage.
         */
        sourceImageRef?: outputs.schemas.Reference;
    }

    /**
     * The status of the block storage.
     */
    export interface BlockStorageStatus {
        /**
         * Reference to the instance the block storage is attached to.
         */
        attachedTo?: outputs.schemas.ReferenceObject;
        conditions: outputs.schemas.StatusCondition[];
        /**
         * Size of the block storage in GB.
         */
        sizeGB: number;
        /**
         * Current phase of the resource: - pending: not available, waiting for other resources - creating: not available, creation started - active: available for data layer usage - updating: available for data layer usage - deleting: maybe still available for data layer user, can fail any moment - error: failed to fulfill the request; would be related to provider issue or customer related input.
         */
        state?: string;
    }

    /**
     * Specification of the instance, including its SKU, network configuration, and storage options.
     */
    export interface InstanceSpec {
        /**
         * Additional NICs attached to this instance
         */
        additionalNicRefs?: outputs.schemas.Reference[];
        /**
         * Anti-affinity group to which this instance belongs. Instances in the same anti-affinity group are placed on different physical hosts. The number of maximum instances in an anti-affinity group is provider-specific.
         */
        antiAffinityGroup?: string;
        /**
         * Reference to the block storage used to store the boot volume of the instance.
         */
        bootVolume: outputs.schemas.VolumeReference;
        dataVolumes?: outputs.schemas.VolumeReference[];
        /**
         * Reference to the primary NIC attached to this instance.
         */
        primaryNicRef?: outputs.schemas.Reference;
        /**
         * Reference to the security group associated with this instance.
         */
        securityGroupRef?: outputs.schemas.Reference;
        /**
         * Reference to the SKU of the instance.
         */
        skuRef: outputs.schemas.Reference;
        /**
         * Provider-specific references to SSH keys used in cloud-init vendorData. These references are used to inject SSH public keys during instance initialization through cloud-init's vendor data configuration.
         */
        sshKeys?: string[];
        /**
         * Cloud-init user data for instance initialization Example cloud-init user configuration with SSH key:
         */
        userData?: string;
        /**
         * Reference to a specific zone within a region
         */
        zone: string;
    }
    /**
     * instanceSpecProvideDefaults sets the appropriate defaults for InstanceSpec
     */
    export function instanceSpecProvideDefaults(val: InstanceSpec): InstanceSpec {
        return {
            ...val,
            bootVolume: outputs.schemas.volumeReferenceProvideDefaults(val.bootVolume),
        };
    }

    /**
     * Current status of the instance.
     */
    export interface InstanceStatus {
        conditions: outputs.schemas.StatusCondition[];
        /**
         * Current power state of the instance.
         */
        powerState: string;
        /**
         * Indicates the time when the instance powerState has updated, basecause the instance was started, stoped or restarted. If the instance was never started the field is `null`.
         */
        powerStateSince?: string;
        /**
         * Current phase of the resource: - pending: not available, waiting for other resources - creating: not available, creation started - active: available for data layer usage - updating: available for data layer usage - deleting: maybe still available for data layer user, can fail any moment - error: failed to fulfill the request; would be related to provider issue or customer related input.
         */
        state?: string;
    }

    /**
     * A reference to a resource using an object. The object contains the same information as the ReferenceURN, but is represented as a structured object. The advantage of this representation is that it can be used to reference resources in different workspaces or regions without the need to specify the full URN.
     */
    export interface Reference {
        /**
         * Provider of the resource. If not set, the provider is inferred from the context.
         */
        provider?: string;
        /**
         * Region of the resource. If not set, the region is inferred from the context.
         */
        region?: string;
        /**
         * Name and type of the resource. Must be in the format `<type>/<name>`. The type is the resource type, and the name is the resource name.
         */
        resource: string;
        /**
         * Tenant of the resource. If not set, the tenant is inferred from the context.
         */
        tenant?: string;
        /**
         * Workspace of the resource. If not set, the workspace is inferred from the context.
         */
        workspace?: string;
    }

    /**
     * A reference to a resource using an object. The object contains the same information as the ReferenceURN, but is represented as a structured object. The advantage of this representation is that it can be used to reference resources in different workspaces or regions without the need to specify the full URN.
     */
    export interface ReferenceObject {
        /**
         * Provider of the resource. If not set, the provider is inferred from the context.
         */
        provider?: string;
        /**
         * Region of the resource. If not set, the region is inferred from the context.
         */
        region?: string;
        /**
         * Name and type of the resource. Must be in the format `<type>/<name>`. The type is the resource type, and the name is the resource name.
         */
        resource: string;
        /**
         * Tenant of the resource. If not set, the tenant is inferred from the context.
         */
        tenant?: string;
        /**
         * Workspace of the resource. If not set, the workspace is inferred from the context.
         */
        workspace?: string;
    }

    /**
     * Metadata for regional resources with name, permission, modification, type, tenant and region information.
     */
    export interface RegionalResourceMetadata {
        /**
         * API version of the resource
         */
        apiVersion: string;
        /**
         * Indicates the time when the resource was created. The field is set by the provider and should not be modified by the user.
         */
        createdAt: string;
        /**
         * If set, indicates the time when the resource was marked for deletion. Resources with this field set are considered pending deletion.
         */
        deletedAt?: string;
        /**
         * Type of the resource
         */
        kind: string;
        /**
         * Indicates the time when the resource was created or last modified. Field is used for "If-Unmodified-Since" logic for concurrency control. The provider guarantees that a modification on a single resource can happen only once every millisecond.
         */
        lastModifiedAt: string;
        /**
         * Resource identifier in dash-case (kebab-case) format. Must start and end with an alphanumeric character. Can contain lowercase letters, numbers, and hyphens. Multiple segments can be joined with dots. Each segment follows the same rules.
         */
        name: string;
        provider: string;
        /**
         * A unique resource name used to reference this resource in other resources. The reference is represented as the full URN (Uniform Resource Name) name of the resource. ### Automatic Prefix Inference In most cases, the prefix of the URN can be automatically derived in the given context. To simplify usage, only the resource type and name might be specified as a reference using the `<type>/<name>` notation. The suffix can be made more specific by adding additional segments separated by slashes. The prefix is automatically inferred from the context. For example, if the resource is a block storage in the same workspace the reference can be specified as `block-storages/my-block-storage`. If the resource is a block storage in a different workspace, the reference can be specified as `workspaces/ws-1/block-storages/my-block-storage`. For automatic prefix inference, the following rules apply: - the version is inferred from the current resource version - the workspace is inferred from the current workspace - the region is inferred from the current region - the provider is inferred from the type and context of the usage The prefix inference is resolved on admission into the full URN format, which makes it mostly suitable for human use.
         */
        ref: string;
        /**
         * Reference to the region where the resource is located
         */
        region: string;
        resource: string;
        /**
         * Incremented on every modification of the resource. Used for optimistic concurrency control.
         */
        resourceVersion: number;
        /**
         * Tenant identifier
         */
        tenant: string;
        verb: string;
    }
    /**
     * regionalResourceMetadataProvideDefaults sets the appropriate defaults for RegionalResourceMetadata
     */
    export function regionalResourceMetadataProvideDefaults(val: RegionalResourceMetadata): RegionalResourceMetadata {
        return {
            ...val,
            apiVersion: (val.apiVersion) ?? "v1",
        };
    }

    /**
     * Metadata for regional resources with name, permission, modification, type, tenant and workspace and region information.
     */
    export interface RegionalWorkspaceResourceMetadata {
        /**
         * API version of the resource
         */
        apiVersion: string;
        /**
         * Indicates the time when the resource was created. The field is set by the provider and should not be modified by the user.
         */
        createdAt: string;
        /**
         * If set, indicates the time when the resource was marked for deletion. Resources with this field set are considered pending deletion.
         */
        deletedAt?: string;
        /**
         * Type of the resource
         */
        kind: string;
        /**
         * Indicates the time when the resource was created or last modified. Field is used for "If-Unmodified-Since" logic for concurrency control. The provider guarantees that a modification on a single resource can happen only once every millisecond.
         */
        lastModifiedAt: string;
        /**
         * Resource identifier in dash-case (kebab-case) format. Must start and end with an alphanumeric character. Can contain lowercase letters, numbers, and hyphens. Multiple segments can be joined with dots. Each segment follows the same rules.
         */
        name: string;
        provider: string;
        /**
         * A unique resource name used to reference this resource in other resources. The reference is represented as the full URN (Uniform Resource Name) name of the resource. ### Automatic Prefix Inference In most cases, the prefix of the URN can be automatically derived in the given context. To simplify usage, only the resource type and name might be specified as a reference using the `<type>/<name>` notation. The suffix can be made more specific by adding additional segments separated by slashes. The prefix is automatically inferred from the context. For example, if the resource is a block storage in the same workspace the reference can be specified as `block-storages/my-block-storage`. If the resource is a block storage in a different workspace, the reference can be specified as `workspaces/ws-1/block-storages/my-block-storage`. For automatic prefix inference, the following rules apply: - the version is inferred from the current resource version - the workspace is inferred from the current workspace - the region is inferred from the current region - the provider is inferred from the type and context of the usage The prefix inference is resolved on admission into the full URN format, which makes it mostly suitable for human use.
         */
        ref: string;
        /**
         * Reference to the region where the resource is located
         */
        region: string;
        resource: string;
        /**
         * Incremented on every modification of the resource. Used for optimistic concurrency control.
         */
        resourceVersion: number;
        /**
         * Tenant identifier
         */
        tenant: string;
        verb: string;
        /**
         * Workspace identifier
         */
        workspace: string;
    }
    /**
     * regionalWorkspaceResourceMetadataProvideDefaults sets the appropriate defaults for RegionalWorkspaceResourceMetadata
     */
    export function regionalWorkspaceResourceMetadataProvideDefaults(val: RegionalWorkspaceResourceMetadata): RegionalWorkspaceResourceMetadata {
        return {
            ...val,
            apiVersion: (val.apiVersion) ?? "v1",
        };
    }

    /**
     * Metadata for response objects.
     */
    export interface ResponseMetadata {
        provider: string;
        resource: string;
        /**
         * Opaque cursor to get the next page. Field is omitted when there are no more pages available.
         */
        skipToken?: string;
        verb: string;
    }

    /**
     * Metadata for SKU resources with name, permission, type, tenant and region information.
     */
    export interface SkuResourceMetadata {
        /**
         * API version of the resource
         */
        apiVersion: string;
        /**
         * Type of the resource
         */
        kind: string;
        /**
         * Resource identifier in dash-case (kebab-case) format. Must start and end with an alphanumeric character. Can contain lowercase letters, numbers, and hyphens. Multiple segments can be joined with dots. Each segment follows the same rules.
         */
        name: string;
        provider: string;
        /**
         * A unique resource name used to reference this resource in other resources. The reference is represented as the full URN (Uniform Resource Name) name of the resource. ### Automatic Prefix Inference In most cases, the prefix of the URN can be automatically derived in the given context. To simplify usage, only the resource type and name might be specified as a reference using the `<type>/<name>` notation. The suffix can be made more specific by adding additional segments separated by slashes. The prefix is automatically inferred from the context. For example, if the resource is a block storage in the same workspace the reference can be specified as `block-storages/my-block-storage`. If the resource is a block storage in a different workspace, the reference can be specified as `workspaces/ws-1/block-storages/my-block-storage`. For automatic prefix inference, the following rules apply: - the version is inferred from the current resource version - the workspace is inferred from the current workspace - the region is inferred from the current region - the provider is inferred from the type and context of the usage The prefix inference is resolved on admission into the full URN format, which makes it mostly suitable for human use.
         */
        ref: string;
        /**
         * Reference to the region where the resource is located
         */
        region: string;
        resource: string;
        /**
         * Tenant identifier
         */
        tenant: string;
        verb: string;
    }
    /**
     * skuResourceMetadataProvideDefaults sets the appropriate defaults for SkuResourceMetadata
     */
    export function skuResourceMetadataProvideDefaults(val: SkuResourceMetadata): SkuResourceMetadata {
        return {
            ...val,
            apiVersion: (val.apiVersion) ?? "v1",
        };
    }

    /**
     * StatusCondition describes the state of a resource at a certain point. Conditions are provider-specific and can represent different states depending on the resource type and provider implementation.
     */
    export interface StatusCondition {
        /**
         * LastTransitionAt is the last time the condition transitioned from one status to another. This should be when the underlying condition changed. If that is not known, then using the time when the API field changed is acceptable.
         */
        lastTransitionAt: string;
        /**
         * A human-readable message indicating details about the transition.
         */
        message?: string;
        /**
         * The reason for the condition's last transition in CamelCase. The specific set of reason values is provider-specific and should be documented by the provider.
         */
        reason?: string;
        /**
         * Current phase of the resource: - pending: not available, waiting for other resources - creating: not available, creation started - active: available for data layer usage - updating: available for data layer usage - deleting: maybe still available for data layer user, can fail any moment - error: failed to fulfill the request; would be related to provider issue or customer related input.
         */
        state: string;
        /**
         * Type of condition. The condition type is provider-specific and should reflect the specific states relevant to your resource.
         */
        type?: string;
    }

    /**
     * Represents a Stock Keeping Unit (SKU) for storage resources. Storage SKUs define performance tiers for storage IOPS and characteristics. Properties, capabilities, and extensions can be found in the metadata.labels sections. Searchable with namespaces like "properties.", "capabilities.", and "extensions.".
     */
    export interface StorageSku {
        /**
         * User-defined key/value pairs that are mutable and can be used to add annotations. The number of annotations is eventually limited by the CSP.
         */
        annotations?: {[key: string]: string};
        /**
         * User-defined key/value pairs that are mutable and can be used to add extensions. Extensions are subject to validation by the CSP, and any value that is not accepted will be rejected during admission.
         */
        extensions?: {[key: string]: string};
        /**
         * User-defined key/value pairs that are mutable and can be used to organize and categorize resources. They can be used to filter resources. The number of labels is eventually limited by the CSP.
         */
        labels?: {[key: string]: string};
        /**
         * Metadata for SKU resources with name, permission, type, tenant and region information.
         */
        metadata?: outputs.schemas.SkuResourceMetadata;
        /**
         * Specification of the storage SKU, including its capabilities and extensions.
         */
        spec?: outputs.schemas.StorageSkuSpec;
    }
    /**
     * storageSkuProvideDefaults sets the appropriate defaults for StorageSku
     */
    export function storageSkuProvideDefaults(val: StorageSku): StorageSku {
        return {
            ...val,
            metadata: (val.metadata ? outputs.schemas.skuResourceMetadataProvideDefaults(val.metadata) : undefined),
        };
    }

    /**
     * Specification of the storage SKU, including its capabilities and extensions.
     */
    export interface StorageSkuSpec {
        /**
         * The number of IOPS (Input/Output Operations Per Second) guaranteed for the storage SKU.
         */
        iops: number;
        /**
         * Minimum volume size for guaranteed performance, in GB.
         */
        minVolumeSize: number;
        /**
         * Type of storage SKU. Can be one of the following: * `local-ephemeral`: Local storage is directly attached to the hypervisor hosting the instance. In the event of a hypervisor failure or instance restart, the data may either be lost or become unavailable. The failure mode depends on the Cloud Service Provider (CSP). Users of local storage should be aware of these risks and implement a robust backup strategy or application level replication of the data. Local storage is typically suited for high-performance workloads requiring low latency and high throughput, where the application layer can handle failures. It is not recommended for workloads demanding high availability or data durability. Example use-cases include caching, temporary data or immutable workloads such as operating system images without local data. * `local-durable`: Local durable storage is similar to local storage but is designed to provide data durability while providing high-performance. It is typically implemented using a redundant storage device or replicated storage solution. Local durable storage is suitable for workloads requiring high performance and low latency, while also ensuring data durability at the cost of availability. The time to restore data may vary depending on the CSP and the will be significantly higher then using `remote-durable` storage. Example use-cases include replicated paxos or raft based databases or replicated databases using synchronous replication, in addition to file storage. * `remote-durable`: Remote storage is a network-attached storage solution designed to provide data redundancy and high availability. While typically slower than local storage, remote storage offers the advantage of being accessible by different hypervisors. This means the storage can be used by different instances running on separate hypervisors, but only one instance at a time. This enabled the recreation of the instance with the same storage on a different hypervisor and therefore greatly reduces the recovery time in case of failure of the hypervisor. Remote storage cannot be attached to multiple instances simultaneously. Example use-cases include file storage or replicated databases using asynchronous replication.
         */
        type: string;
    }

    /**
     * Represents a connection between a Block Storage and an a user of the block storage.
     */
    export interface VolumeReference {
        /**
         * Reference to the block storage used to store the volume.
         */
        deviceRef: outputs.schemas.Reference;
        /**
         * The connection type depends on the type of device and type of block storage.
         */
        type?: string;
    }
    /**
     * volumeReferenceProvideDefaults sets the appropriate defaults for VolumeReference
     */
    export function volumeReferenceProvideDefaults(val: VolumeReference): VolumeReference {
        return {
            ...val,
            type: (val.type) ?? "virtio",
        };
    }

    /**
     * Status of the workspace, including the number of resources in the workspace.
     */
    export interface WorkspaceStatus {
        conditions: outputs.schemas.StatusCondition[];
        /**
         * Number of resources currently in the workspace
         */
        resourceCount?: number;
        /**
         * Current phase of the resource: - pending: not available, waiting for other resources - creating: not available, creation started - active: available for data layer usage - updating: available for data layer usage - deleting: maybe still available for data layer user, can fail any moment - error: failed to fulfill the request; would be related to provider issue or customer related input.
         */
        state?: string;
    }

}
