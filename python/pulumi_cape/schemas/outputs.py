# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities
from . import outputs

__all__ = [
    'BlockStorageSpec',
    'BlockStorageStatus',
    'InstanceSpec',
    'InstanceStatus',
    'Reference',
    'ReferenceObject',
    'RegionalResourceMetadata',
    'RegionalWorkspaceResourceMetadata',
    'ResponseMetadata',
    'SkuResourceMetadata',
    'StatusCondition',
    'StorageSku',
    'StorageSkuSpec',
    'VolumeReference',
    'WorkspaceStatus',
]

@pulumi.output_type
class BlockStorageSpec(dict):
    """
    References the SKU used for this block. If a reference to the source image is used as the base for creating this block storage.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sizeGB":
            suggest = "size_gb"
        elif key == "skuRef":
            suggest = "sku_ref"
        elif key == "sourceImageRef":
            suggest = "source_image_ref"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BlockStorageSpec. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BlockStorageSpec.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BlockStorageSpec.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 size_gb: _builtins.int,
                 sku_ref: 'outputs.Reference',
                 source_image_ref: Optional['outputs.Reference'] = None):
        """
        References the SKU used for this block. If a reference to the source image is used as the base for creating this block storage.

        :param _builtins.int size_gb: Size of the block storage in GB.
        :param 'Reference' sku_ref: Reference to the SKU of the block storage.
        :param 'Reference' source_image_ref: Reference to the source image used as the base for creating the block storage.
        """
        pulumi.set(__self__, "size_gb", size_gb)
        pulumi.set(__self__, "sku_ref", sku_ref)
        if source_image_ref is not None:
            pulumi.set(__self__, "source_image_ref", source_image_ref)

    @_builtins.property
    @pulumi.getter(name="sizeGB")
    def size_gb(self) -> _builtins.int:
        """
        Size of the block storage in GB.
        """
        return pulumi.get(self, "size_gb")

    @_builtins.property
    @pulumi.getter(name="skuRef")
    def sku_ref(self) -> 'outputs.Reference':
        """
        Reference to the SKU of the block storage.
        """
        return pulumi.get(self, "sku_ref")

    @_builtins.property
    @pulumi.getter(name="sourceImageRef")
    def source_image_ref(self) -> Optional['outputs.Reference']:
        """
        Reference to the source image used as the base for creating the block storage.
        """
        return pulumi.get(self, "source_image_ref")


@pulumi.output_type
class BlockStorageStatus(dict):
    """
    The status of the block storage.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sizeGB":
            suggest = "size_gb"
        elif key == "attachedTo":
            suggest = "attached_to"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BlockStorageStatus. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BlockStorageStatus.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BlockStorageStatus.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 conditions: Sequence['outputs.StatusCondition'],
                 size_gb: _builtins.int,
                 attached_to: Optional['outputs.ReferenceObject'] = None,
                 state: Optional[_builtins.str] = None):
        """
        The status of the block storage.

        :param _builtins.int size_gb: Size of the block storage in GB.
        :param 'ReferenceObject' attached_to: Reference to the instance the block storage is attached to.
        :param _builtins.str state: Current phase of the resource: - pending: not available, waiting for other resources - creating: not available, creation started - active: available for data layer usage - updating: available for data layer usage - deleting: maybe still available for data layer user, can fail any moment - error: failed to fulfill the request; would be related to provider issue or customer related input.
        """
        pulumi.set(__self__, "conditions", conditions)
        pulumi.set(__self__, "size_gb", size_gb)
        if attached_to is not None:
            pulumi.set(__self__, "attached_to", attached_to)
        if state is not None:
            pulumi.set(__self__, "state", state)

    @_builtins.property
    @pulumi.getter
    def conditions(self) -> Sequence['outputs.StatusCondition']:
        return pulumi.get(self, "conditions")

    @_builtins.property
    @pulumi.getter(name="sizeGB")
    def size_gb(self) -> _builtins.int:
        """
        Size of the block storage in GB.
        """
        return pulumi.get(self, "size_gb")

    @_builtins.property
    @pulumi.getter(name="attachedTo")
    def attached_to(self) -> Optional['outputs.ReferenceObject']:
        """
        Reference to the instance the block storage is attached to.
        """
        return pulumi.get(self, "attached_to")

    @_builtins.property
    @pulumi.getter
    def state(self) -> Optional[_builtins.str]:
        """
        Current phase of the resource: - pending: not available, waiting for other resources - creating: not available, creation started - active: available for data layer usage - updating: available for data layer usage - deleting: maybe still available for data layer user, can fail any moment - error: failed to fulfill the request; would be related to provider issue or customer related input.
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class InstanceSpec(dict):
    """
    Specification of the instance, including its SKU, network configuration, and storage options.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bootVolume":
            suggest = "boot_volume"
        elif key == "skuRef":
            suggest = "sku_ref"
        elif key == "additionalNicRefs":
            suggest = "additional_nic_refs"
        elif key == "antiAffinityGroup":
            suggest = "anti_affinity_group"
        elif key == "dataVolumes":
            suggest = "data_volumes"
        elif key == "primaryNicRef":
            suggest = "primary_nic_ref"
        elif key == "securityGroupRef":
            suggest = "security_group_ref"
        elif key == "sshKeys":
            suggest = "ssh_keys"
        elif key == "userData":
            suggest = "user_data"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstanceSpec. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstanceSpec.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstanceSpec.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 boot_volume: 'outputs.VolumeReference',
                 sku_ref: 'outputs.Reference',
                 zone: _builtins.str,
                 additional_nic_refs: Optional[Sequence['outputs.Reference']] = None,
                 anti_affinity_group: Optional[_builtins.str] = None,
                 data_volumes: Optional[Sequence['outputs.VolumeReference']] = None,
                 primary_nic_ref: Optional['outputs.Reference'] = None,
                 security_group_ref: Optional['outputs.Reference'] = None,
                 ssh_keys: Optional[Sequence[_builtins.str]] = None,
                 user_data: Optional[_builtins.str] = None):
        """
        Specification of the instance, including its SKU, network configuration, and storage options.

        :param 'VolumeReference' boot_volume: Reference to the block storage used to store the boot volume of the instance.
        :param 'Reference' sku_ref: Reference to the SKU of the instance.
        :param _builtins.str zone: Reference to a specific zone within a region
        :param Sequence['Reference'] additional_nic_refs: Additional NICs attached to this instance
        :param _builtins.str anti_affinity_group: Anti-affinity group to which this instance belongs. Instances in the same anti-affinity group are placed on different physical hosts. The number of maximum instances in an anti-affinity group is provider-specific.
        :param 'Reference' primary_nic_ref: Reference to the primary NIC attached to this instance.
        :param 'Reference' security_group_ref: Reference to the security group associated with this instance.
        :param Sequence[_builtins.str] ssh_keys: Provider-specific references to SSH keys used in cloud-init vendorData. These references are used to inject SSH public keys during instance initialization through cloud-init's vendor data configuration.
        :param _builtins.str user_data: Cloud-init user data for instance initialization Example cloud-init user configuration with SSH key:
        """
        pulumi.set(__self__, "boot_volume", boot_volume)
        pulumi.set(__self__, "sku_ref", sku_ref)
        pulumi.set(__self__, "zone", zone)
        if additional_nic_refs is not None:
            pulumi.set(__self__, "additional_nic_refs", additional_nic_refs)
        if anti_affinity_group is not None:
            pulumi.set(__self__, "anti_affinity_group", anti_affinity_group)
        if data_volumes is not None:
            pulumi.set(__self__, "data_volumes", data_volumes)
        if primary_nic_ref is not None:
            pulumi.set(__self__, "primary_nic_ref", primary_nic_ref)
        if security_group_ref is not None:
            pulumi.set(__self__, "security_group_ref", security_group_ref)
        if ssh_keys is not None:
            pulumi.set(__self__, "ssh_keys", ssh_keys)
        if user_data is not None:
            pulumi.set(__self__, "user_data", user_data)

    @_builtins.property
    @pulumi.getter(name="bootVolume")
    def boot_volume(self) -> 'outputs.VolumeReference':
        """
        Reference to the block storage used to store the boot volume of the instance.
        """
        return pulumi.get(self, "boot_volume")

    @_builtins.property
    @pulumi.getter(name="skuRef")
    def sku_ref(self) -> 'outputs.Reference':
        """
        Reference to the SKU of the instance.
        """
        return pulumi.get(self, "sku_ref")

    @_builtins.property
    @pulumi.getter
    def zone(self) -> _builtins.str:
        """
        Reference to a specific zone within a region
        """
        return pulumi.get(self, "zone")

    @_builtins.property
    @pulumi.getter(name="additionalNicRefs")
    def additional_nic_refs(self) -> Optional[Sequence['outputs.Reference']]:
        """
        Additional NICs attached to this instance
        """
        return pulumi.get(self, "additional_nic_refs")

    @_builtins.property
    @pulumi.getter(name="antiAffinityGroup")
    def anti_affinity_group(self) -> Optional[_builtins.str]:
        """
        Anti-affinity group to which this instance belongs. Instances in the same anti-affinity group are placed on different physical hosts. The number of maximum instances in an anti-affinity group is provider-specific.
        """
        return pulumi.get(self, "anti_affinity_group")

    @_builtins.property
    @pulumi.getter(name="dataVolumes")
    def data_volumes(self) -> Optional[Sequence['outputs.VolumeReference']]:
        return pulumi.get(self, "data_volumes")

    @_builtins.property
    @pulumi.getter(name="primaryNicRef")
    def primary_nic_ref(self) -> Optional['outputs.Reference']:
        """
        Reference to the primary NIC attached to this instance.
        """
        return pulumi.get(self, "primary_nic_ref")

    @_builtins.property
    @pulumi.getter(name="securityGroupRef")
    def security_group_ref(self) -> Optional['outputs.Reference']:
        """
        Reference to the security group associated with this instance.
        """
        return pulumi.get(self, "security_group_ref")

    @_builtins.property
    @pulumi.getter(name="sshKeys")
    def ssh_keys(self) -> Optional[Sequence[_builtins.str]]:
        """
        Provider-specific references to SSH keys used in cloud-init vendorData. These references are used to inject SSH public keys during instance initialization through cloud-init's vendor data configuration.
        """
        return pulumi.get(self, "ssh_keys")

    @_builtins.property
    @pulumi.getter(name="userData")
    def user_data(self) -> Optional[_builtins.str]:
        """
        Cloud-init user data for instance initialization Example cloud-init user configuration with SSH key:
        """
        return pulumi.get(self, "user_data")


@pulumi.output_type
class InstanceStatus(dict):
    """
    Current status of the instance.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "powerState":
            suggest = "power_state"
        elif key == "powerStateSince":
            suggest = "power_state_since"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstanceStatus. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstanceStatus.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstanceStatus.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 conditions: Sequence['outputs.StatusCondition'],
                 power_state: _builtins.str,
                 power_state_since: Optional[_builtins.str] = None,
                 state: Optional[_builtins.str] = None):
        """
        Current status of the instance.

        :param _builtins.str power_state: Current power state of the instance.
        :param _builtins.str power_state_since: Indicates the time when the instance powerState has updated, basecause the instance was started, stoped or restarted. If the instance was never started the field is `null`.
        :param _builtins.str state: Current phase of the resource: - pending: not available, waiting for other resources - creating: not available, creation started - active: available for data layer usage - updating: available for data layer usage - deleting: maybe still available for data layer user, can fail any moment - error: failed to fulfill the request; would be related to provider issue or customer related input.
        """
        pulumi.set(__self__, "conditions", conditions)
        pulumi.set(__self__, "power_state", power_state)
        if power_state_since is not None:
            pulumi.set(__self__, "power_state_since", power_state_since)
        if state is not None:
            pulumi.set(__self__, "state", state)

    @_builtins.property
    @pulumi.getter
    def conditions(self) -> Sequence['outputs.StatusCondition']:
        return pulumi.get(self, "conditions")

    @_builtins.property
    @pulumi.getter(name="powerState")
    def power_state(self) -> _builtins.str:
        """
        Current power state of the instance.
        """
        return pulumi.get(self, "power_state")

    @_builtins.property
    @pulumi.getter(name="powerStateSince")
    def power_state_since(self) -> Optional[_builtins.str]:
        """
        Indicates the time when the instance powerState has updated, basecause the instance was started, stoped or restarted. If the instance was never started the field is `null`.
        """
        return pulumi.get(self, "power_state_since")

    @_builtins.property
    @pulumi.getter
    def state(self) -> Optional[_builtins.str]:
        """
        Current phase of the resource: - pending: not available, waiting for other resources - creating: not available, creation started - active: available for data layer usage - updating: available for data layer usage - deleting: maybe still available for data layer user, can fail any moment - error: failed to fulfill the request; would be related to provider issue or customer related input.
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class Reference(dict):
    """
    A reference to a resource using an object. The object contains the same information as the ReferenceURN, but is represented as a structured object. The advantage of this representation is that it can be used to reference resources in different workspaces or regions without the need to specify the full URN.
    """
    def __init__(__self__, *,
                 resource: _builtins.str,
                 provider: Optional[_builtins.str] = None,
                 region: Optional[_builtins.str] = None,
                 tenant: Optional[_builtins.str] = None,
                 workspace: Optional[_builtins.str] = None):
        """
        A reference to a resource using an object. The object contains the same information as the ReferenceURN, but is represented as a structured object. The advantage of this representation is that it can be used to reference resources in different workspaces or regions without the need to specify the full URN.

        :param _builtins.str resource: Name and type of the resource. Must be in the format `<type>/<name>`. The type is the resource type, and the name is the resource name.
        :param _builtins.str provider: Provider of the resource. If not set, the provider is inferred from the context.
        :param _builtins.str region: Region of the resource. If not set, the region is inferred from the context.
        :param _builtins.str tenant: Tenant of the resource. If not set, the tenant is inferred from the context.
        :param _builtins.str workspace: Workspace of the resource. If not set, the workspace is inferred from the context.
        """
        pulumi.set(__self__, "resource", resource)
        if provider is not None:
            pulumi.set(__self__, "provider", provider)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if tenant is not None:
            pulumi.set(__self__, "tenant", tenant)
        if workspace is not None:
            pulumi.set(__self__, "workspace", workspace)

    @_builtins.property
    @pulumi.getter
    def resource(self) -> _builtins.str:
        """
        Name and type of the resource. Must be in the format `<type>/<name>`. The type is the resource type, and the name is the resource name.
        """
        return pulumi.get(self, "resource")

    @_builtins.property
    @pulumi.getter
    def provider(self) -> Optional[_builtins.str]:
        """
        Provider of the resource. If not set, the provider is inferred from the context.
        """
        return pulumi.get(self, "provider")

    @_builtins.property
    @pulumi.getter
    def region(self) -> Optional[_builtins.str]:
        """
        Region of the resource. If not set, the region is inferred from the context.
        """
        return pulumi.get(self, "region")

    @_builtins.property
    @pulumi.getter
    def tenant(self) -> Optional[_builtins.str]:
        """
        Tenant of the resource. If not set, the tenant is inferred from the context.
        """
        return pulumi.get(self, "tenant")

    @_builtins.property
    @pulumi.getter
    def workspace(self) -> Optional[_builtins.str]:
        """
        Workspace of the resource. If not set, the workspace is inferred from the context.
        """
        return pulumi.get(self, "workspace")


@pulumi.output_type
class ReferenceObject(dict):
    """
    A reference to a resource using an object. The object contains the same information as the ReferenceURN, but is represented as a structured object. The advantage of this representation is that it can be used to reference resources in different workspaces or regions without the need to specify the full URN.
    """
    def __init__(__self__, *,
                 resource: _builtins.str,
                 provider: Optional[_builtins.str] = None,
                 region: Optional[_builtins.str] = None,
                 tenant: Optional[_builtins.str] = None,
                 workspace: Optional[_builtins.str] = None):
        """
        A reference to a resource using an object. The object contains the same information as the ReferenceURN, but is represented as a structured object. The advantage of this representation is that it can be used to reference resources in different workspaces or regions without the need to specify the full URN.

        :param _builtins.str resource: Name and type of the resource. Must be in the format `<type>/<name>`. The type is the resource type, and the name is the resource name.
        :param _builtins.str provider: Provider of the resource. If not set, the provider is inferred from the context.
        :param _builtins.str region: Region of the resource. If not set, the region is inferred from the context.
        :param _builtins.str tenant: Tenant of the resource. If not set, the tenant is inferred from the context.
        :param _builtins.str workspace: Workspace of the resource. If not set, the workspace is inferred from the context.
        """
        pulumi.set(__self__, "resource", resource)
        if provider is not None:
            pulumi.set(__self__, "provider", provider)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if tenant is not None:
            pulumi.set(__self__, "tenant", tenant)
        if workspace is not None:
            pulumi.set(__self__, "workspace", workspace)

    @_builtins.property
    @pulumi.getter
    def resource(self) -> _builtins.str:
        """
        Name and type of the resource. Must be in the format `<type>/<name>`. The type is the resource type, and the name is the resource name.
        """
        return pulumi.get(self, "resource")

    @_builtins.property
    @pulumi.getter
    def provider(self) -> Optional[_builtins.str]:
        """
        Provider of the resource. If not set, the provider is inferred from the context.
        """
        return pulumi.get(self, "provider")

    @_builtins.property
    @pulumi.getter
    def region(self) -> Optional[_builtins.str]:
        """
        Region of the resource. If not set, the region is inferred from the context.
        """
        return pulumi.get(self, "region")

    @_builtins.property
    @pulumi.getter
    def tenant(self) -> Optional[_builtins.str]:
        """
        Tenant of the resource. If not set, the tenant is inferred from the context.
        """
        return pulumi.get(self, "tenant")

    @_builtins.property
    @pulumi.getter
    def workspace(self) -> Optional[_builtins.str]:
        """
        Workspace of the resource. If not set, the workspace is inferred from the context.
        """
        return pulumi.get(self, "workspace")


@pulumi.output_type
class RegionalResourceMetadata(dict):
    """
    Metadata for regional resources with name, permission, modification, type, tenant and region information.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiVersion":
            suggest = "api_version"
        elif key == "createdAt":
            suggest = "created_at"
        elif key == "lastModifiedAt":
            suggest = "last_modified_at"
        elif key == "resourceVersion":
            suggest = "resource_version"
        elif key == "deletedAt":
            suggest = "deleted_at"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RegionalResourceMetadata. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RegionalResourceMetadata.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RegionalResourceMetadata.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_version: Optional[_builtins.str] = None,
                 created_at: _builtins.str,
                 kind: _builtins.str,
                 last_modified_at: _builtins.str,
                 name: _builtins.str,
                 provider: _builtins.str,
                 ref: _builtins.str,
                 region: _builtins.str,
                 resource: _builtins.str,
                 resource_version: _builtins.int,
                 tenant: _builtins.str,
                 verb: _builtins.str,
                 deleted_at: Optional[_builtins.str] = None):
        """
        Metadata for regional resources with name, permission, modification, type, tenant and region information.

        :param _builtins.str api_version: API version of the resource
        :param _builtins.str created_at: Indicates the time when the resource was created. The field is set by the provider and should not be modified by the user.
        :param _builtins.str kind: Type of the resource
        :param _builtins.str last_modified_at: Indicates the time when the resource was created or last modified. Field is used for "If-Unmodified-Since" logic for concurrency control. The provider guarantees that a modification on a single resource can happen only once every millisecond.
        :param _builtins.str name: Resource identifier in dash-case (kebab-case) format. Must start and end with an alphanumeric character. Can contain lowercase letters, numbers, and hyphens. Multiple segments can be joined with dots. Each segment follows the same rules.
        :param _builtins.str ref: A unique resource name used to reference this resource in other resources. The reference is represented as the full URN (Uniform Resource Name) name of the resource. ### Automatic Prefix Inference In most cases, the prefix of the URN can be automatically derived in the given context. To simplify usage, only the resource type and name might be specified as a reference using the `<type>/<name>` notation. The suffix can be made more specific by adding additional segments separated by slashes. The prefix is automatically inferred from the context. For example, if the resource is a block storage in the same workspace the reference can be specified as `block-storages/my-block-storage`. If the resource is a block storage in a different workspace, the reference can be specified as `workspaces/ws-1/block-storages/my-block-storage`. For automatic prefix inference, the following rules apply: - the version is inferred from the current resource version - the workspace is inferred from the current workspace - the region is inferred from the current region - the provider is inferred from the type and context of the usage The prefix inference is resolved on admission into the full URN format, which makes it mostly suitable for human use.
        :param _builtins.str region: Reference to the region where the resource is located
        :param _builtins.int resource_version: Incremented on every modification of the resource. Used for optimistic concurrency control.
        :param _builtins.str tenant: Tenant identifier
        :param _builtins.str deleted_at: If set, indicates the time when the resource was marked for deletion. Resources with this field set are considered pending deletion.
        """
        if api_version is None:
            api_version = 'v1'
        pulumi.set(__self__, "api_version", api_version)
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "kind", kind)
        pulumi.set(__self__, "last_modified_at", last_modified_at)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "provider", provider)
        pulumi.set(__self__, "ref", ref)
        pulumi.set(__self__, "region", region)
        pulumi.set(__self__, "resource", resource)
        pulumi.set(__self__, "resource_version", resource_version)
        pulumi.set(__self__, "tenant", tenant)
        pulumi.set(__self__, "verb", verb)
        if deleted_at is not None:
            pulumi.set(__self__, "deleted_at", deleted_at)

    @_builtins.property
    @pulumi.getter(name="apiVersion")
    def api_version(self) -> _builtins.str:
        """
        API version of the resource
        """
        return pulumi.get(self, "api_version")

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> _builtins.str:
        """
        Indicates the time when the resource was created. The field is set by the provider and should not be modified by the user.
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter
    def kind(self) -> _builtins.str:
        """
        Type of the resource
        """
        return pulumi.get(self, "kind")

    @_builtins.property
    @pulumi.getter(name="lastModifiedAt")
    def last_modified_at(self) -> _builtins.str:
        """
        Indicates the time when the resource was created or last modified. Field is used for "If-Unmodified-Since" logic for concurrency control. The provider guarantees that a modification on a single resource can happen only once every millisecond.
        """
        return pulumi.get(self, "last_modified_at")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Resource identifier in dash-case (kebab-case) format. Must start and end with an alphanumeric character. Can contain lowercase letters, numbers, and hyphens. Multiple segments can be joined with dots. Each segment follows the same rules.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def provider(self) -> _builtins.str:
        return pulumi.get(self, "provider")

    @_builtins.property
    @pulumi.getter
    def ref(self) -> _builtins.str:
        """
        A unique resource name used to reference this resource in other resources. The reference is represented as the full URN (Uniform Resource Name) name of the resource. ### Automatic Prefix Inference In most cases, the prefix of the URN can be automatically derived in the given context. To simplify usage, only the resource type and name might be specified as a reference using the `<type>/<name>` notation. The suffix can be made more specific by adding additional segments separated by slashes. The prefix is automatically inferred from the context. For example, if the resource is a block storage in the same workspace the reference can be specified as `block-storages/my-block-storage`. If the resource is a block storage in a different workspace, the reference can be specified as `workspaces/ws-1/block-storages/my-block-storage`. For automatic prefix inference, the following rules apply: - the version is inferred from the current resource version - the workspace is inferred from the current workspace - the region is inferred from the current region - the provider is inferred from the type and context of the usage The prefix inference is resolved on admission into the full URN format, which makes it mostly suitable for human use.
        """
        return pulumi.get(self, "ref")

    @_builtins.property
    @pulumi.getter
    def region(self) -> _builtins.str:
        """
        Reference to the region where the resource is located
        """
        return pulumi.get(self, "region")

    @_builtins.property
    @pulumi.getter
    def resource(self) -> _builtins.str:
        return pulumi.get(self, "resource")

    @_builtins.property
    @pulumi.getter(name="resourceVersion")
    def resource_version(self) -> _builtins.int:
        """
        Incremented on every modification of the resource. Used for optimistic concurrency control.
        """
        return pulumi.get(self, "resource_version")

    @_builtins.property
    @pulumi.getter
    def tenant(self) -> _builtins.str:
        """
        Tenant identifier
        """
        return pulumi.get(self, "tenant")

    @_builtins.property
    @pulumi.getter
    def verb(self) -> _builtins.str:
        return pulumi.get(self, "verb")

    @_builtins.property
    @pulumi.getter(name="deletedAt")
    def deleted_at(self) -> Optional[_builtins.str]:
        """
        If set, indicates the time when the resource was marked for deletion. Resources with this field set are considered pending deletion.
        """
        return pulumi.get(self, "deleted_at")


@pulumi.output_type
class RegionalWorkspaceResourceMetadata(dict):
    """
    Metadata for regional resources with name, permission, modification, type, tenant and workspace and region information.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiVersion":
            suggest = "api_version"
        elif key == "createdAt":
            suggest = "created_at"
        elif key == "lastModifiedAt":
            suggest = "last_modified_at"
        elif key == "resourceVersion":
            suggest = "resource_version"
        elif key == "deletedAt":
            suggest = "deleted_at"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RegionalWorkspaceResourceMetadata. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RegionalWorkspaceResourceMetadata.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RegionalWorkspaceResourceMetadata.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_version: Optional[_builtins.str] = None,
                 created_at: _builtins.str,
                 kind: _builtins.str,
                 last_modified_at: _builtins.str,
                 name: _builtins.str,
                 provider: _builtins.str,
                 ref: _builtins.str,
                 region: _builtins.str,
                 resource: _builtins.str,
                 resource_version: _builtins.int,
                 tenant: _builtins.str,
                 verb: _builtins.str,
                 workspace: _builtins.str,
                 deleted_at: Optional[_builtins.str] = None):
        """
        Metadata for regional resources with name, permission, modification, type, tenant and workspace and region information.

        :param _builtins.str api_version: API version of the resource
        :param _builtins.str created_at: Indicates the time when the resource was created. The field is set by the provider and should not be modified by the user.
        :param _builtins.str kind: Type of the resource
        :param _builtins.str last_modified_at: Indicates the time when the resource was created or last modified. Field is used for "If-Unmodified-Since" logic for concurrency control. The provider guarantees that a modification on a single resource can happen only once every millisecond.
        :param _builtins.str name: Resource identifier in dash-case (kebab-case) format. Must start and end with an alphanumeric character. Can contain lowercase letters, numbers, and hyphens. Multiple segments can be joined with dots. Each segment follows the same rules.
        :param _builtins.str ref: A unique resource name used to reference this resource in other resources. The reference is represented as the full URN (Uniform Resource Name) name of the resource. ### Automatic Prefix Inference In most cases, the prefix of the URN can be automatically derived in the given context. To simplify usage, only the resource type and name might be specified as a reference using the `<type>/<name>` notation. The suffix can be made more specific by adding additional segments separated by slashes. The prefix is automatically inferred from the context. For example, if the resource is a block storage in the same workspace the reference can be specified as `block-storages/my-block-storage`. If the resource is a block storage in a different workspace, the reference can be specified as `workspaces/ws-1/block-storages/my-block-storage`. For automatic prefix inference, the following rules apply: - the version is inferred from the current resource version - the workspace is inferred from the current workspace - the region is inferred from the current region - the provider is inferred from the type and context of the usage The prefix inference is resolved on admission into the full URN format, which makes it mostly suitable for human use.
        :param _builtins.str region: Reference to the region where the resource is located
        :param _builtins.int resource_version: Incremented on every modification of the resource. Used for optimistic concurrency control.
        :param _builtins.str tenant: Tenant identifier
        :param _builtins.str workspace: Workspace identifier
        :param _builtins.str deleted_at: If set, indicates the time when the resource was marked for deletion. Resources with this field set are considered pending deletion.
        """
        if api_version is None:
            api_version = 'v1'
        pulumi.set(__self__, "api_version", api_version)
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "kind", kind)
        pulumi.set(__self__, "last_modified_at", last_modified_at)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "provider", provider)
        pulumi.set(__self__, "ref", ref)
        pulumi.set(__self__, "region", region)
        pulumi.set(__self__, "resource", resource)
        pulumi.set(__self__, "resource_version", resource_version)
        pulumi.set(__self__, "tenant", tenant)
        pulumi.set(__self__, "verb", verb)
        pulumi.set(__self__, "workspace", workspace)
        if deleted_at is not None:
            pulumi.set(__self__, "deleted_at", deleted_at)

    @_builtins.property
    @pulumi.getter(name="apiVersion")
    def api_version(self) -> _builtins.str:
        """
        API version of the resource
        """
        return pulumi.get(self, "api_version")

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> _builtins.str:
        """
        Indicates the time when the resource was created. The field is set by the provider and should not be modified by the user.
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter
    def kind(self) -> _builtins.str:
        """
        Type of the resource
        """
        return pulumi.get(self, "kind")

    @_builtins.property
    @pulumi.getter(name="lastModifiedAt")
    def last_modified_at(self) -> _builtins.str:
        """
        Indicates the time when the resource was created or last modified. Field is used for "If-Unmodified-Since" logic for concurrency control. The provider guarantees that a modification on a single resource can happen only once every millisecond.
        """
        return pulumi.get(self, "last_modified_at")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Resource identifier in dash-case (kebab-case) format. Must start and end with an alphanumeric character. Can contain lowercase letters, numbers, and hyphens. Multiple segments can be joined with dots. Each segment follows the same rules.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def provider(self) -> _builtins.str:
        return pulumi.get(self, "provider")

    @_builtins.property
    @pulumi.getter
    def ref(self) -> _builtins.str:
        """
        A unique resource name used to reference this resource in other resources. The reference is represented as the full URN (Uniform Resource Name) name of the resource. ### Automatic Prefix Inference In most cases, the prefix of the URN can be automatically derived in the given context. To simplify usage, only the resource type and name might be specified as a reference using the `<type>/<name>` notation. The suffix can be made more specific by adding additional segments separated by slashes. The prefix is automatically inferred from the context. For example, if the resource is a block storage in the same workspace the reference can be specified as `block-storages/my-block-storage`. If the resource is a block storage in a different workspace, the reference can be specified as `workspaces/ws-1/block-storages/my-block-storage`. For automatic prefix inference, the following rules apply: - the version is inferred from the current resource version - the workspace is inferred from the current workspace - the region is inferred from the current region - the provider is inferred from the type and context of the usage The prefix inference is resolved on admission into the full URN format, which makes it mostly suitable for human use.
        """
        return pulumi.get(self, "ref")

    @_builtins.property
    @pulumi.getter
    def region(self) -> _builtins.str:
        """
        Reference to the region where the resource is located
        """
        return pulumi.get(self, "region")

    @_builtins.property
    @pulumi.getter
    def resource(self) -> _builtins.str:
        return pulumi.get(self, "resource")

    @_builtins.property
    @pulumi.getter(name="resourceVersion")
    def resource_version(self) -> _builtins.int:
        """
        Incremented on every modification of the resource. Used for optimistic concurrency control.
        """
        return pulumi.get(self, "resource_version")

    @_builtins.property
    @pulumi.getter
    def tenant(self) -> _builtins.str:
        """
        Tenant identifier
        """
        return pulumi.get(self, "tenant")

    @_builtins.property
    @pulumi.getter
    def verb(self) -> _builtins.str:
        return pulumi.get(self, "verb")

    @_builtins.property
    @pulumi.getter
    def workspace(self) -> _builtins.str:
        """
        Workspace identifier
        """
        return pulumi.get(self, "workspace")

    @_builtins.property
    @pulumi.getter(name="deletedAt")
    def deleted_at(self) -> Optional[_builtins.str]:
        """
        If set, indicates the time when the resource was marked for deletion. Resources with this field set are considered pending deletion.
        """
        return pulumi.get(self, "deleted_at")


@pulumi.output_type
class ResponseMetadata(dict):
    """
    Metadata for response objects.
    """
    def __init__(__self__, *,
                 provider: _builtins.str,
                 resource: _builtins.str,
                 verb: _builtins.str,
                 skip_token: Optional[_builtins.str] = None):
        """
        Metadata for response objects.

        :param _builtins.str skip_token: Opaque cursor to get the next page. Field is omitted when there are no more pages available.
        """
        pulumi.set(__self__, "provider", provider)
        pulumi.set(__self__, "resource", resource)
        pulumi.set(__self__, "verb", verb)
        if skip_token is not None:
            pulumi.set(__self__, "skip_token", skip_token)

    @_builtins.property
    @pulumi.getter
    def provider(self) -> _builtins.str:
        return pulumi.get(self, "provider")

    @_builtins.property
    @pulumi.getter
    def resource(self) -> _builtins.str:
        return pulumi.get(self, "resource")

    @_builtins.property
    @pulumi.getter
    def verb(self) -> _builtins.str:
        return pulumi.get(self, "verb")

    @_builtins.property
    @pulumi.getter(name="skipToken")
    def skip_token(self) -> Optional[_builtins.str]:
        """
        Opaque cursor to get the next page. Field is omitted when there are no more pages available.
        """
        return pulumi.get(self, "skip_token")


@pulumi.output_type
class SkuResourceMetadata(dict):
    """
    Metadata for SKU resources with name, permission, type, tenant and region information.
    """
    def __init__(__self__, *,
                 api_version: Optional[_builtins.str] = None,
                 kind: _builtins.str,
                 name: _builtins.str,
                 provider: _builtins.str,
                 ref: _builtins.str,
                 region: _builtins.str,
                 resource: _builtins.str,
                 tenant: _builtins.str,
                 verb: _builtins.str):
        """
        Metadata for SKU resources with name, permission, type, tenant and region information.

        :param _builtins.str api_version: API version of the resource
        :param _builtins.str kind: Type of the resource
        :param _builtins.str name: Resource identifier in dash-case (kebab-case) format. Must start and end with an alphanumeric character. Can contain lowercase letters, numbers, and hyphens. Multiple segments can be joined with dots. Each segment follows the same rules.
        :param _builtins.str ref: A unique resource name used to reference this resource in other resources. The reference is represented as the full URN (Uniform Resource Name) name of the resource. ### Automatic Prefix Inference In most cases, the prefix of the URN can be automatically derived in the given context. To simplify usage, only the resource type and name might be specified as a reference using the `<type>/<name>` notation. The suffix can be made more specific by adding additional segments separated by slashes. The prefix is automatically inferred from the context. For example, if the resource is a block storage in the same workspace the reference can be specified as `block-storages/my-block-storage`. If the resource is a block storage in a different workspace, the reference can be specified as `workspaces/ws-1/block-storages/my-block-storage`. For automatic prefix inference, the following rules apply: - the version is inferred from the current resource version - the workspace is inferred from the current workspace - the region is inferred from the current region - the provider is inferred from the type and context of the usage The prefix inference is resolved on admission into the full URN format, which makes it mostly suitable for human use.
        :param _builtins.str region: Reference to the region where the resource is located
        :param _builtins.str tenant: Tenant identifier
        """
        if api_version is None:
            api_version = 'v1'
        pulumi.set(__self__, "api_version", api_version)
        pulumi.set(__self__, "kind", kind)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "provider", provider)
        pulumi.set(__self__, "ref", ref)
        pulumi.set(__self__, "region", region)
        pulumi.set(__self__, "resource", resource)
        pulumi.set(__self__, "tenant", tenant)
        pulumi.set(__self__, "verb", verb)

    @_builtins.property
    @pulumi.getter(name="apiVersion")
    def api_version(self) -> _builtins.str:
        """
        API version of the resource
        """
        return pulumi.get(self, "api_version")

    @_builtins.property
    @pulumi.getter
    def kind(self) -> _builtins.str:
        """
        Type of the resource
        """
        return pulumi.get(self, "kind")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Resource identifier in dash-case (kebab-case) format. Must start and end with an alphanumeric character. Can contain lowercase letters, numbers, and hyphens. Multiple segments can be joined with dots. Each segment follows the same rules.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def provider(self) -> _builtins.str:
        return pulumi.get(self, "provider")

    @_builtins.property
    @pulumi.getter
    def ref(self) -> _builtins.str:
        """
        A unique resource name used to reference this resource in other resources. The reference is represented as the full URN (Uniform Resource Name) name of the resource. ### Automatic Prefix Inference In most cases, the prefix of the URN can be automatically derived in the given context. To simplify usage, only the resource type and name might be specified as a reference using the `<type>/<name>` notation. The suffix can be made more specific by adding additional segments separated by slashes. The prefix is automatically inferred from the context. For example, if the resource is a block storage in the same workspace the reference can be specified as `block-storages/my-block-storage`. If the resource is a block storage in a different workspace, the reference can be specified as `workspaces/ws-1/block-storages/my-block-storage`. For automatic prefix inference, the following rules apply: - the version is inferred from the current resource version - the workspace is inferred from the current workspace - the region is inferred from the current region - the provider is inferred from the type and context of the usage The prefix inference is resolved on admission into the full URN format, which makes it mostly suitable for human use.
        """
        return pulumi.get(self, "ref")

    @_builtins.property
    @pulumi.getter
    def region(self) -> _builtins.str:
        """
        Reference to the region where the resource is located
        """
        return pulumi.get(self, "region")

    @_builtins.property
    @pulumi.getter
    def resource(self) -> _builtins.str:
        return pulumi.get(self, "resource")

    @_builtins.property
    @pulumi.getter
    def tenant(self) -> _builtins.str:
        """
        Tenant identifier
        """
        return pulumi.get(self, "tenant")

    @_builtins.property
    @pulumi.getter
    def verb(self) -> _builtins.str:
        return pulumi.get(self, "verb")


@pulumi.output_type
class StatusCondition(dict):
    """
    StatusCondition describes the state of a resource at a certain point. Conditions are provider-specific and can represent different states depending on the resource type and provider implementation.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "lastTransitionAt":
            suggest = "last_transition_at"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StatusCondition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StatusCondition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StatusCondition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 last_transition_at: _builtins.str,
                 state: _builtins.str,
                 message: Optional[_builtins.str] = None,
                 reason: Optional[_builtins.str] = None,
                 type: Optional[_builtins.str] = None):
        """
        StatusCondition describes the state of a resource at a certain point. Conditions are provider-specific and can represent different states depending on the resource type and provider implementation.

        :param _builtins.str last_transition_at: LastTransitionAt is the last time the condition transitioned from one status to another. This should be when the underlying condition changed. If that is not known, then using the time when the API field changed is acceptable.
        :param _builtins.str state: Current phase of the resource: - pending: not available, waiting for other resources - creating: not available, creation started - active: available for data layer usage - updating: available for data layer usage - deleting: maybe still available for data layer user, can fail any moment - error: failed to fulfill the request; would be related to provider issue or customer related input.
        :param _builtins.str message: A human-readable message indicating details about the transition.
        :param _builtins.str reason: The reason for the condition's last transition in CamelCase. The specific set of reason values is provider-specific and should be documented by the provider.
        :param _builtins.str type: Type of condition. The condition type is provider-specific and should reflect the specific states relevant to your resource.
        """
        pulumi.set(__self__, "last_transition_at", last_transition_at)
        pulumi.set(__self__, "state", state)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if reason is not None:
            pulumi.set(__self__, "reason", reason)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter(name="lastTransitionAt")
    def last_transition_at(self) -> _builtins.str:
        """
        LastTransitionAt is the last time the condition transitioned from one status to another. This should be when the underlying condition changed. If that is not known, then using the time when the API field changed is acceptable.
        """
        return pulumi.get(self, "last_transition_at")

    @_builtins.property
    @pulumi.getter
    def state(self) -> _builtins.str:
        """
        Current phase of the resource: - pending: not available, waiting for other resources - creating: not available, creation started - active: available for data layer usage - updating: available for data layer usage - deleting: maybe still available for data layer user, can fail any moment - error: failed to fulfill the request; would be related to provider issue or customer related input.
        """
        return pulumi.get(self, "state")

    @_builtins.property
    @pulumi.getter
    def message(self) -> Optional[_builtins.str]:
        """
        A human-readable message indicating details about the transition.
        """
        return pulumi.get(self, "message")

    @_builtins.property
    @pulumi.getter
    def reason(self) -> Optional[_builtins.str]:
        """
        The reason for the condition's last transition in CamelCase. The specific set of reason values is provider-specific and should be documented by the provider.
        """
        return pulumi.get(self, "reason")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        Type of condition. The condition type is provider-specific and should reflect the specific states relevant to your resource.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class StorageSku(dict):
    """
    Represents a Stock Keeping Unit (SKU) for storage resources. Storage SKUs define performance tiers for storage IOPS and characteristics. Properties, capabilities, and extensions can be found in the metadata.labels sections. Searchable with namespaces like "properties.", "capabilities.", and "extensions.".
    """
    def __init__(__self__, *,
                 annotations: Optional[Mapping[str, _builtins.str]] = None,
                 extensions: Optional[Mapping[str, _builtins.str]] = None,
                 labels: Optional[Mapping[str, _builtins.str]] = None,
                 metadata: Optional['outputs.SkuResourceMetadata'] = None,
                 spec: Optional['outputs.StorageSkuSpec'] = None):
        """
        Represents a Stock Keeping Unit (SKU) for storage resources. Storage SKUs define performance tiers for storage IOPS and characteristics. Properties, capabilities, and extensions can be found in the metadata.labels sections. Searchable with namespaces like "properties.", "capabilities.", and "extensions.".

        :param Mapping[str, _builtins.str] annotations: User-defined key/value pairs that are mutable and can be used to add annotations. The number of annotations is eventually limited by the CSP.
        :param Mapping[str, _builtins.str] extensions: User-defined key/value pairs that are mutable and can be used to add extensions. Extensions are subject to validation by the CSP, and any value that is not accepted will be rejected during admission.
        :param Mapping[str, _builtins.str] labels: User-defined key/value pairs that are mutable and can be used to organize and categorize resources. They can be used to filter resources. The number of labels is eventually limited by the CSP.
        :param 'SkuResourceMetadata' metadata: Metadata for SKU resources with name, permission, type, tenant and region information.
        :param 'StorageSkuSpec' spec: Specification of the storage SKU, including its capabilities and extensions.
        """
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if extensions is not None:
            pulumi.set(__self__, "extensions", extensions)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)
        if spec is not None:
            pulumi.set(__self__, "spec", spec)

    @_builtins.property
    @pulumi.getter
    def annotations(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        User-defined key/value pairs that are mutable and can be used to add annotations. The number of annotations is eventually limited by the CSP.
        """
        return pulumi.get(self, "annotations")

    @_builtins.property
    @pulumi.getter
    def extensions(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        User-defined key/value pairs that are mutable and can be used to add extensions. Extensions are subject to validation by the CSP, and any value that is not accepted will be rejected during admission.
        """
        return pulumi.get(self, "extensions")

    @_builtins.property
    @pulumi.getter
    def labels(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        User-defined key/value pairs that are mutable and can be used to organize and categorize resources. They can be used to filter resources. The number of labels is eventually limited by the CSP.
        """
        return pulumi.get(self, "labels")

    @_builtins.property
    @pulumi.getter
    def metadata(self) -> Optional['outputs.SkuResourceMetadata']:
        """
        Metadata for SKU resources with name, permission, type, tenant and region information.
        """
        return pulumi.get(self, "metadata")

    @_builtins.property
    @pulumi.getter
    def spec(self) -> Optional['outputs.StorageSkuSpec']:
        """
        Specification of the storage SKU, including its capabilities and extensions.
        """
        return pulumi.get(self, "spec")


@pulumi.output_type
class StorageSkuSpec(dict):
    """
    Specification of the storage SKU, including its capabilities and extensions.
    """
    def __init__(__self__, *,
                 iops: _builtins.int,
                 min_volume_size: _builtins.int,
                 type: _builtins.str):
        """
        Specification of the storage SKU, including its capabilities and extensions.

        :param _builtins.int iops: The number of IOPS (Input/Output Operations Per Second) guaranteed for the storage SKU.
        :param _builtins.int min_volume_size: Minimum volume size for guaranteed performance, in GB.
        :param _builtins.str type: Type of storage SKU. Can be one of the following: * `local-ephemeral`: Local storage is directly attached to the hypervisor hosting the instance. In the event of a hypervisor failure or instance restart, the data may either be lost or become unavailable. The failure mode depends on the Cloud Service Provider (CSP). Users of local storage should be aware of these risks and implement a robust backup strategy or application level replication of the data. Local storage is typically suited for high-performance workloads requiring low latency and high throughput, where the application layer can handle failures. It is not recommended for workloads demanding high availability or data durability. Example use-cases include caching, temporary data or immutable workloads such as operating system images without local data. * `local-durable`: Local durable storage is similar to local storage but is designed to provide data durability while providing high-performance. It is typically implemented using a redundant storage device or replicated storage solution. Local durable storage is suitable for workloads requiring high performance and low latency, while also ensuring data durability at the cost of availability. The time to restore data may vary depending on the CSP and the will be significantly higher then using `remote-durable` storage. Example use-cases include replicated paxos or raft based databases or replicated databases using synchronous replication, in addition to file storage. * `remote-durable`: Remote storage is a network-attached storage solution designed to provide data redundancy and high availability. While typically slower than local storage, remote storage offers the advantage of being accessible by different hypervisors. This means the storage can be used by different instances running on separate hypervisors, but only one instance at a time. This enabled the recreation of the instance with the same storage on a different hypervisor and therefore greatly reduces the recovery time in case of failure of the hypervisor. Remote storage cannot be attached to multiple instances simultaneously. Example use-cases include file storage or replicated databases using asynchronous replication.
        """
        pulumi.set(__self__, "iops", iops)
        pulumi.set(__self__, "min_volume_size", min_volume_size)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def iops(self) -> _builtins.int:
        """
        The number of IOPS (Input/Output Operations Per Second) guaranteed for the storage SKU.
        """
        return pulumi.get(self, "iops")

    @_builtins.property
    @pulumi.getter(name="minVolumeSize")
    def min_volume_size(self) -> _builtins.int:
        """
        Minimum volume size for guaranteed performance, in GB.
        """
        return pulumi.get(self, "min_volume_size")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Type of storage SKU. Can be one of the following: * `local-ephemeral`: Local storage is directly attached to the hypervisor hosting the instance. In the event of a hypervisor failure or instance restart, the data may either be lost or become unavailable. The failure mode depends on the Cloud Service Provider (CSP). Users of local storage should be aware of these risks and implement a robust backup strategy or application level replication of the data. Local storage is typically suited for high-performance workloads requiring low latency and high throughput, where the application layer can handle failures. It is not recommended for workloads demanding high availability or data durability. Example use-cases include caching, temporary data or immutable workloads such as operating system images without local data. * `local-durable`: Local durable storage is similar to local storage but is designed to provide data durability while providing high-performance. It is typically implemented using a redundant storage device or replicated storage solution. Local durable storage is suitable for workloads requiring high performance and low latency, while also ensuring data durability at the cost of availability. The time to restore data may vary depending on the CSP and the will be significantly higher then using `remote-durable` storage. Example use-cases include replicated paxos or raft based databases or replicated databases using synchronous replication, in addition to file storage. * `remote-durable`: Remote storage is a network-attached storage solution designed to provide data redundancy and high availability. While typically slower than local storage, remote storage offers the advantage of being accessible by different hypervisors. This means the storage can be used by different instances running on separate hypervisors, but only one instance at a time. This enabled the recreation of the instance with the same storage on a different hypervisor and therefore greatly reduces the recovery time in case of failure of the hypervisor. Remote storage cannot be attached to multiple instances simultaneously. Example use-cases include file storage or replicated databases using asynchronous replication.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class VolumeReference(dict):
    """
    Represents a connection between a Block Storage and an a user of the block storage.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deviceRef":
            suggest = "device_ref"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VolumeReference. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VolumeReference.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VolumeReference.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 device_ref: 'outputs.Reference',
                 type: Optional[_builtins.str] = None):
        """
        Represents a connection between a Block Storage and an a user of the block storage.

        :param 'Reference' device_ref: Reference to the block storage used to store the volume.
        :param _builtins.str type: The connection type depends on the type of device and type of block storage.
        """
        pulumi.set(__self__, "device_ref", device_ref)
        if type is None:
            type = 'virtio'
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter(name="deviceRef")
    def device_ref(self) -> 'outputs.Reference':
        """
        Reference to the block storage used to store the volume.
        """
        return pulumi.get(self, "device_ref")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        The connection type depends on the type of device and type of block storage.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class WorkspaceStatus(dict):
    """
    Status of the workspace, including the number of resources in the workspace.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "resourceCount":
            suggest = "resource_count"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkspaceStatus. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkspaceStatus.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkspaceStatus.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 conditions: Sequence['outputs.StatusCondition'],
                 resource_count: Optional[_builtins.int] = None,
                 state: Optional[_builtins.str] = None):
        """
        Status of the workspace, including the number of resources in the workspace.

        :param _builtins.int resource_count: Number of resources currently in the workspace
        :param _builtins.str state: Current phase of the resource: - pending: not available, waiting for other resources - creating: not available, creation started - active: available for data layer usage - updating: available for data layer usage - deleting: maybe still available for data layer user, can fail any moment - error: failed to fulfill the request; would be related to provider issue or customer related input.
        """
        pulumi.set(__self__, "conditions", conditions)
        if resource_count is not None:
            pulumi.set(__self__, "resource_count", resource_count)
        if state is not None:
            pulumi.set(__self__, "state", state)

    @_builtins.property
    @pulumi.getter
    def conditions(self) -> Sequence['outputs.StatusCondition']:
        return pulumi.get(self, "conditions")

    @_builtins.property
    @pulumi.getter(name="resourceCount")
    def resource_count(self) -> Optional[_builtins.int]:
        """
        Number of resources currently in the workspace
        """
        return pulumi.get(self, "resource_count")

    @_builtins.property
    @pulumi.getter
    def state(self) -> Optional[_builtins.str]:
        """
        Current phase of the resource: - pending: not available, waiting for other resources - creating: not available, creation started - active: available for data layer usage - updating: available for data layer usage - deleting: maybe still available for data layer user, can fail any moment - error: failed to fulfill the request; would be related to provider issue or customer related input.
        """
        return pulumi.get(self, "state")


