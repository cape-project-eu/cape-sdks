// Code generated by pulumi-language-go DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package workspace

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/cape/sdk/go/cape/internal"
	"github.com/pulumi/cape/sdk/go/cape/schemas"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// A workspace is a collection of resources. Can contain multiple resources of different types, and it can be used to manage the lifecycle of those resources.
type Workspace struct {
	pulumi.CustomResourceState

	// User-defined key/value pairs that are mutable and can be used to add annotations. The number of annotations is eventually limited by the CSP.
	Annotations pulumi.StringMapOutput `pulumi:"annotations"`
	// User-defined key/value pairs that are mutable and can be used to add extensions. Extensions are subject to validation by the CSP, and any value that is not accepted will be rejected during admission.
	Extensions pulumi.StringMapOutput `pulumi:"extensions"`
	// User-defined key/value pairs that are mutable and can be used to organize and categorize resources. They can be used to filter resources. The number of labels is eventually limited by the CSP.
	Labels pulumi.StringMapOutput `pulumi:"labels"`
	// Metadata for regional resources with name, permission, modification, type, tenant and region information.
	Metadata schemas.RegionalResourceMetadataOutput `pulumi:"metadata"`
	// Specification of the workspace, including its capabilities and extensions.
	Spec pulumi.MapOutput `pulumi:"spec"`
	// Status of the workspace, including the number of resources in the workspace.
	Status schemas.WorkspaceStatusOutput `pulumi:"status"`
	// The tenant for the resource. If omitted, the provider default is used.
	Tenant pulumi.StringPtrOutput `pulumi:"tenant"`
}

// NewWorkspace registers a new resource with the given unique name, arguments, and options.
func NewWorkspace(ctx *pulumi.Context,
	name string, args *WorkspaceArgs, opts ...pulumi.ResourceOption) (*Workspace, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.Spec == nil {
		return nil, errors.New("invalid value for required argument 'Spec'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource Workspace
	err := ctx.RegisterResource("cape:workspace:Workspace", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetWorkspace gets an existing Workspace resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetWorkspace(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *WorkspaceState, opts ...pulumi.ResourceOption) (*Workspace, error) {
	var resource Workspace
	err := ctx.ReadResource("cape:workspace:Workspace", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering Workspace resources.
type workspaceState struct {
}

type WorkspaceState struct {
}

func (WorkspaceState) ElementType() reflect.Type {
	return reflect.TypeOf((*workspaceState)(nil)).Elem()
}

type workspaceArgs struct {
	// User-defined key/value pairs that are mutable and can be used to add annotations. The number of annotations is eventually limited by the CSP.
	Annotations map[string]string `pulumi:"annotations"`
	// User-defined key/value pairs that are mutable and can be used to add extensions. Extensions are subject to validation by the CSP, and any value that is not accepted will be rejected during admission.
	Extensions map[string]string `pulumi:"extensions"`
	// User-defined key/value pairs that are mutable and can be used to organize and categorize resources. They can be used to filter resources. The number of labels is eventually limited by the CSP.
	Labels map[string]string `pulumi:"labels"`
	// Specification of the workspace, including its capabilities and extensions.
	Spec map[string]interface{} `pulumi:"spec"`
	// The tenant for the resource. If omitted, the provider default is used.
	Tenant *string `pulumi:"tenant"`
}

// The set of arguments for constructing a Workspace resource.
type WorkspaceArgs struct {
	// User-defined key/value pairs that are mutable and can be used to add annotations. The number of annotations is eventually limited by the CSP.
	Annotations pulumi.StringMapInput
	// User-defined key/value pairs that are mutable and can be used to add extensions. Extensions are subject to validation by the CSP, and any value that is not accepted will be rejected during admission.
	Extensions pulumi.StringMapInput
	// User-defined key/value pairs that are mutable and can be used to organize and categorize resources. They can be used to filter resources. The number of labels is eventually limited by the CSP.
	Labels pulumi.StringMapInput
	// Specification of the workspace, including its capabilities and extensions.
	Spec pulumi.MapInput
	// The tenant for the resource. If omitted, the provider default is used.
	Tenant pulumi.StringPtrInput
}

func (WorkspaceArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*workspaceArgs)(nil)).Elem()
}

type WorkspaceInput interface {
	pulumi.Input

	ToWorkspaceOutput() WorkspaceOutput
	ToWorkspaceOutputWithContext(ctx context.Context) WorkspaceOutput
}

func (*Workspace) ElementType() reflect.Type {
	return reflect.TypeOf((**Workspace)(nil)).Elem()
}

func (i *Workspace) ToWorkspaceOutput() WorkspaceOutput {
	return i.ToWorkspaceOutputWithContext(context.Background())
}

func (i *Workspace) ToWorkspaceOutputWithContext(ctx context.Context) WorkspaceOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WorkspaceOutput)
}

// WorkspaceArrayInput is an input type that accepts WorkspaceArray and WorkspaceArrayOutput values.
// You can construct a concrete instance of `WorkspaceArrayInput` via:
//
//	WorkspaceArray{ WorkspaceArgs{...} }
type WorkspaceArrayInput interface {
	pulumi.Input

	ToWorkspaceArrayOutput() WorkspaceArrayOutput
	ToWorkspaceArrayOutputWithContext(context.Context) WorkspaceArrayOutput
}

type WorkspaceArray []WorkspaceInput

func (WorkspaceArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Workspace)(nil)).Elem()
}

func (i WorkspaceArray) ToWorkspaceArrayOutput() WorkspaceArrayOutput {
	return i.ToWorkspaceArrayOutputWithContext(context.Background())
}

func (i WorkspaceArray) ToWorkspaceArrayOutputWithContext(ctx context.Context) WorkspaceArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WorkspaceArrayOutput)
}

// WorkspaceMapInput is an input type that accepts WorkspaceMap and WorkspaceMapOutput values.
// You can construct a concrete instance of `WorkspaceMapInput` via:
//
//	WorkspaceMap{ "key": WorkspaceArgs{...} }
type WorkspaceMapInput interface {
	pulumi.Input

	ToWorkspaceMapOutput() WorkspaceMapOutput
	ToWorkspaceMapOutputWithContext(context.Context) WorkspaceMapOutput
}

type WorkspaceMap map[string]WorkspaceInput

func (WorkspaceMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Workspace)(nil)).Elem()
}

func (i WorkspaceMap) ToWorkspaceMapOutput() WorkspaceMapOutput {
	return i.ToWorkspaceMapOutputWithContext(context.Background())
}

func (i WorkspaceMap) ToWorkspaceMapOutputWithContext(ctx context.Context) WorkspaceMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WorkspaceMapOutput)
}

type WorkspaceOutput struct{ *pulumi.OutputState }

func (WorkspaceOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Workspace)(nil)).Elem()
}

func (o WorkspaceOutput) ToWorkspaceOutput() WorkspaceOutput {
	return o
}

func (o WorkspaceOutput) ToWorkspaceOutputWithContext(ctx context.Context) WorkspaceOutput {
	return o
}

// User-defined key/value pairs that are mutable and can be used to add annotations. The number of annotations is eventually limited by the CSP.
func (o WorkspaceOutput) Annotations() pulumi.StringMapOutput {
	return o.ApplyT(func(v *Workspace) pulumi.StringMapOutput { return v.Annotations }).(pulumi.StringMapOutput)
}

// User-defined key/value pairs that are mutable and can be used to add extensions. Extensions are subject to validation by the CSP, and any value that is not accepted will be rejected during admission.
func (o WorkspaceOutput) Extensions() pulumi.StringMapOutput {
	return o.ApplyT(func(v *Workspace) pulumi.StringMapOutput { return v.Extensions }).(pulumi.StringMapOutput)
}

// User-defined key/value pairs that are mutable and can be used to organize and categorize resources. They can be used to filter resources. The number of labels is eventually limited by the CSP.
func (o WorkspaceOutput) Labels() pulumi.StringMapOutput {
	return o.ApplyT(func(v *Workspace) pulumi.StringMapOutput { return v.Labels }).(pulumi.StringMapOutput)
}

// Metadata for regional resources with name, permission, modification, type, tenant and region information.
func (o WorkspaceOutput) Metadata() schemas.RegionalResourceMetadataOutput {
	return o.ApplyT(func(v *Workspace) schemas.RegionalResourceMetadataOutput { return v.Metadata }).(schemas.RegionalResourceMetadataOutput)
}

// Specification of the workspace, including its capabilities and extensions.
func (o WorkspaceOutput) Spec() pulumi.MapOutput {
	return o.ApplyT(func(v *Workspace) pulumi.MapOutput { return v.Spec }).(pulumi.MapOutput)
}

// Status of the workspace, including the number of resources in the workspace.
func (o WorkspaceOutput) Status() schemas.WorkspaceStatusOutput {
	return o.ApplyT(func(v *Workspace) schemas.WorkspaceStatusOutput { return v.Status }).(schemas.WorkspaceStatusOutput)
}

// The tenant for the resource. If omitted, the provider default is used.
func (o WorkspaceOutput) Tenant() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Workspace) pulumi.StringPtrOutput { return v.Tenant }).(pulumi.StringPtrOutput)
}

type WorkspaceArrayOutput struct{ *pulumi.OutputState }

func (WorkspaceArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Workspace)(nil)).Elem()
}

func (o WorkspaceArrayOutput) ToWorkspaceArrayOutput() WorkspaceArrayOutput {
	return o
}

func (o WorkspaceArrayOutput) ToWorkspaceArrayOutputWithContext(ctx context.Context) WorkspaceArrayOutput {
	return o
}

func (o WorkspaceArrayOutput) Index(i pulumi.IntInput) WorkspaceOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *Workspace {
		return vs[0].([]*Workspace)[vs[1].(int)]
	}).(WorkspaceOutput)
}

type WorkspaceMapOutput struct{ *pulumi.OutputState }

func (WorkspaceMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Workspace)(nil)).Elem()
}

func (o WorkspaceMapOutput) ToWorkspaceMapOutput() WorkspaceMapOutput {
	return o
}

func (o WorkspaceMapOutput) ToWorkspaceMapOutputWithContext(ctx context.Context) WorkspaceMapOutput {
	return o
}

func (o WorkspaceMapOutput) MapIndex(k pulumi.StringInput) WorkspaceOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *Workspace {
		return vs[0].(map[string]*Workspace)[vs[1].(string)]
	}).(WorkspaceOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*WorkspaceInput)(nil)).Elem(), &Workspace{})
	pulumi.RegisterInputType(reflect.TypeOf((*WorkspaceArrayInput)(nil)).Elem(), WorkspaceArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*WorkspaceMapInput)(nil)).Elem(), WorkspaceMap{})
	pulumi.RegisterOutputType(WorkspaceOutput{})
	pulumi.RegisterOutputType(WorkspaceArrayOutput{})
	pulumi.RegisterOutputType(WorkspaceMapOutput{})
}
