// Code generated by pulumi-language-go DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package compute

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/cape/sdk/go/cape/internal"
	"github.com/pulumi/cape/sdk/go/cape/schemas"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// Instance resource representing a virtual machine in the cloud provider's infrastructure. This resource is used to manage the lifecycle of the instance, including its creation, updates, and deletion.
type Instance struct {
	pulumi.CustomResourceState

	// User-defined key/value pairs that are mutable and can be used to add annotations. The number of annotations is eventually limited by the CSP.
	Annotations pulumi.StringMapOutput `pulumi:"annotations"`
	// User-defined key/value pairs that are mutable and can be used to add extensions. Extensions are subject to validation by the CSP, and any value that is not accepted will be rejected during admission.
	Extensions pulumi.StringMapOutput `pulumi:"extensions"`
	// User-defined key/value pairs that are mutable and can be used to organize and categorize resources. They can be used to filter resources. The number of labels is eventually limited by the CSP.
	Labels pulumi.StringMapOutput `pulumi:"labels"`
	// Metadata for regional resources with name, permission, modification, type, tenant and workspace and region information.
	Metadata schemas.RegionalWorkspaceResourceMetadataOutput `pulumi:"metadata"`
	// Specification of the instance, including its SKU, network configuration, and storage options.
	Spec schemas.InstanceSpecOutput `pulumi:"spec"`
	// Current status of the instance.
	Status schemas.InstanceStatusOutput `pulumi:"status"`
	// The tenant for the resource. If omitted, the provider default is used.
	Tenant pulumi.StringPtrOutput `pulumi:"tenant"`
	// The workspace for the resource. If omitted, the provider default is used. Must be configured by either means.
	Workspace pulumi.StringPtrOutput `pulumi:"workspace"`
}

// NewInstance registers a new resource with the given unique name, arguments, and options.
func NewInstance(ctx *pulumi.Context,
	name string, args *InstanceArgs, opts ...pulumi.ResourceOption) (*Instance, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.Spec == nil {
		return nil, errors.New("invalid value for required argument 'Spec'")
	}
	args.Spec = args.Spec.ToInstanceSpecOutput().ApplyT(func(v schemas.InstanceSpec) schemas.InstanceSpec { return *v.Defaults() }).(schemas.InstanceSpecOutput)
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource Instance
	err := ctx.RegisterResource("cape:compute:Instance", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetInstance gets an existing Instance resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetInstance(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *InstanceState, opts ...pulumi.ResourceOption) (*Instance, error) {
	var resource Instance
	err := ctx.ReadResource("cape:compute:Instance", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering Instance resources.
type instanceState struct {
}

type InstanceState struct {
}

func (InstanceState) ElementType() reflect.Type {
	return reflect.TypeOf((*instanceState)(nil)).Elem()
}

type instanceArgs struct {
	// User-defined key/value pairs that are mutable and can be used to add annotations. The number of annotations is eventually limited by the CSP.
	Annotations map[string]string `pulumi:"annotations"`
	// User-defined key/value pairs that are mutable and can be used to add extensions. Extensions are subject to validation by the CSP, and any value that is not accepted will be rejected during admission.
	Extensions map[string]string `pulumi:"extensions"`
	// User-defined key/value pairs that are mutable and can be used to organize and categorize resources. They can be used to filter resources. The number of labels is eventually limited by the CSP.
	Labels map[string]string `pulumi:"labels"`
	// Specification of the instance, including its SKU, network configuration, and storage options.
	Spec schemas.InstanceSpec `pulumi:"spec"`
	// The tenant for the resource. If omitted, the provider default is used.
	Tenant *string `pulumi:"tenant"`
	// The workspace for the resource. If omitted, the provider default is used. Must be configured by either means.
	Workspace *string `pulumi:"workspace"`
}

// The set of arguments for constructing a Instance resource.
type InstanceArgs struct {
	// User-defined key/value pairs that are mutable and can be used to add annotations. The number of annotations is eventually limited by the CSP.
	Annotations pulumi.StringMapInput
	// User-defined key/value pairs that are mutable and can be used to add extensions. Extensions are subject to validation by the CSP, and any value that is not accepted will be rejected during admission.
	Extensions pulumi.StringMapInput
	// User-defined key/value pairs that are mutable and can be used to organize and categorize resources. They can be used to filter resources. The number of labels is eventually limited by the CSP.
	Labels pulumi.StringMapInput
	// Specification of the instance, including its SKU, network configuration, and storage options.
	Spec schemas.InstanceSpecInput
	// The tenant for the resource. If omitted, the provider default is used.
	Tenant pulumi.StringPtrInput
	// The workspace for the resource. If omitted, the provider default is used. Must be configured by either means.
	Workspace pulumi.StringPtrInput
}

func (InstanceArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*instanceArgs)(nil)).Elem()
}

type InstanceInput interface {
	pulumi.Input

	ToInstanceOutput() InstanceOutput
	ToInstanceOutputWithContext(ctx context.Context) InstanceOutput
}

func (*Instance) ElementType() reflect.Type {
	return reflect.TypeOf((**Instance)(nil)).Elem()
}

func (i *Instance) ToInstanceOutput() InstanceOutput {
	return i.ToInstanceOutputWithContext(context.Background())
}

func (i *Instance) ToInstanceOutputWithContext(ctx context.Context) InstanceOutput {
	return pulumi.ToOutputWithContext(ctx, i).(InstanceOutput)
}

// InstanceArrayInput is an input type that accepts InstanceArray and InstanceArrayOutput values.
// You can construct a concrete instance of `InstanceArrayInput` via:
//
//	InstanceArray{ InstanceArgs{...} }
type InstanceArrayInput interface {
	pulumi.Input

	ToInstanceArrayOutput() InstanceArrayOutput
	ToInstanceArrayOutputWithContext(context.Context) InstanceArrayOutput
}

type InstanceArray []InstanceInput

func (InstanceArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Instance)(nil)).Elem()
}

func (i InstanceArray) ToInstanceArrayOutput() InstanceArrayOutput {
	return i.ToInstanceArrayOutputWithContext(context.Background())
}

func (i InstanceArray) ToInstanceArrayOutputWithContext(ctx context.Context) InstanceArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(InstanceArrayOutput)
}

// InstanceMapInput is an input type that accepts InstanceMap and InstanceMapOutput values.
// You can construct a concrete instance of `InstanceMapInput` via:
//
//	InstanceMap{ "key": InstanceArgs{...} }
type InstanceMapInput interface {
	pulumi.Input

	ToInstanceMapOutput() InstanceMapOutput
	ToInstanceMapOutputWithContext(context.Context) InstanceMapOutput
}

type InstanceMap map[string]InstanceInput

func (InstanceMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Instance)(nil)).Elem()
}

func (i InstanceMap) ToInstanceMapOutput() InstanceMapOutput {
	return i.ToInstanceMapOutputWithContext(context.Background())
}

func (i InstanceMap) ToInstanceMapOutputWithContext(ctx context.Context) InstanceMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(InstanceMapOutput)
}

type InstanceOutput struct{ *pulumi.OutputState }

func (InstanceOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Instance)(nil)).Elem()
}

func (o InstanceOutput) ToInstanceOutput() InstanceOutput {
	return o
}

func (o InstanceOutput) ToInstanceOutputWithContext(ctx context.Context) InstanceOutput {
	return o
}

// User-defined key/value pairs that are mutable and can be used to add annotations. The number of annotations is eventually limited by the CSP.
func (o InstanceOutput) Annotations() pulumi.StringMapOutput {
	return o.ApplyT(func(v *Instance) pulumi.StringMapOutput { return v.Annotations }).(pulumi.StringMapOutput)
}

// User-defined key/value pairs that are mutable and can be used to add extensions. Extensions are subject to validation by the CSP, and any value that is not accepted will be rejected during admission.
func (o InstanceOutput) Extensions() pulumi.StringMapOutput {
	return o.ApplyT(func(v *Instance) pulumi.StringMapOutput { return v.Extensions }).(pulumi.StringMapOutput)
}

// User-defined key/value pairs that are mutable and can be used to organize and categorize resources. They can be used to filter resources. The number of labels is eventually limited by the CSP.
func (o InstanceOutput) Labels() pulumi.StringMapOutput {
	return o.ApplyT(func(v *Instance) pulumi.StringMapOutput { return v.Labels }).(pulumi.StringMapOutput)
}

// Metadata for regional resources with name, permission, modification, type, tenant and workspace and region information.
func (o InstanceOutput) Metadata() schemas.RegionalWorkspaceResourceMetadataOutput {
	return o.ApplyT(func(v *Instance) schemas.RegionalWorkspaceResourceMetadataOutput { return v.Metadata }).(schemas.RegionalWorkspaceResourceMetadataOutput)
}

// Specification of the instance, including its SKU, network configuration, and storage options.
func (o InstanceOutput) Spec() schemas.InstanceSpecOutput {
	return o.ApplyT(func(v *Instance) schemas.InstanceSpecOutput { return v.Spec }).(schemas.InstanceSpecOutput)
}

// Current status of the instance.
func (o InstanceOutput) Status() schemas.InstanceStatusOutput {
	return o.ApplyT(func(v *Instance) schemas.InstanceStatusOutput { return v.Status }).(schemas.InstanceStatusOutput)
}

// The tenant for the resource. If omitted, the provider default is used.
func (o InstanceOutput) Tenant() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Instance) pulumi.StringPtrOutput { return v.Tenant }).(pulumi.StringPtrOutput)
}

// The workspace for the resource. If omitted, the provider default is used. Must be configured by either means.
func (o InstanceOutput) Workspace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Instance) pulumi.StringPtrOutput { return v.Workspace }).(pulumi.StringPtrOutput)
}

type InstanceArrayOutput struct{ *pulumi.OutputState }

func (InstanceArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Instance)(nil)).Elem()
}

func (o InstanceArrayOutput) ToInstanceArrayOutput() InstanceArrayOutput {
	return o
}

func (o InstanceArrayOutput) ToInstanceArrayOutputWithContext(ctx context.Context) InstanceArrayOutput {
	return o
}

func (o InstanceArrayOutput) Index(i pulumi.IntInput) InstanceOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *Instance {
		return vs[0].([]*Instance)[vs[1].(int)]
	}).(InstanceOutput)
}

type InstanceMapOutput struct{ *pulumi.OutputState }

func (InstanceMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Instance)(nil)).Elem()
}

func (o InstanceMapOutput) ToInstanceMapOutput() InstanceMapOutput {
	return o
}

func (o InstanceMapOutput) ToInstanceMapOutputWithContext(ctx context.Context) InstanceMapOutput {
	return o
}

func (o InstanceMapOutput) MapIndex(k pulumi.StringInput) InstanceOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *Instance {
		return vs[0].(map[string]*Instance)[vs[1].(string)]
	}).(InstanceOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*InstanceInput)(nil)).Elem(), &Instance{})
	pulumi.RegisterInputType(reflect.TypeOf((*InstanceArrayInput)(nil)).Elem(), InstanceArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*InstanceMapInput)(nil)).Elem(), InstanceMap{})
	pulumi.RegisterOutputType(InstanceOutput{})
	pulumi.RegisterOutputType(InstanceArrayOutput{})
	pulumi.RegisterOutputType(InstanceMapOutput{})
}
