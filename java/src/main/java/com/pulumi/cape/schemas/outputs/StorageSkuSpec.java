// *** WARNING: this file was generated by pulumi-language-java. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.cape.schemas.outputs;

import com.pulumi.core.annotations.CustomType;
import com.pulumi.exceptions.MissingRequiredPropertyException;
import java.lang.Integer;
import java.lang.String;
import java.util.Objects;

@CustomType
public final class StorageSkuSpec {
    /**
     * @return The number of IOPS (Input/Output Operations Per Second) guaranteed for the storage SKU.
     * 
     */
    private Integer iops;
    /**
     * @return Minimum volume size for guaranteed performance, in GB.
     * 
     */
    private Integer minVolumeSize;
    /**
     * @return Type of storage SKU. Can be one of the following: * `local-ephemeral`: Local storage is directly attached to the hypervisor hosting the instance. In the event of a hypervisor failure or instance restart, the data may either be lost or become unavailable. The failure mode depends on the Cloud Service Provider (CSP). Users of local storage should be aware of these risks and implement a robust backup strategy or application level replication of the data. Local storage is typically suited for high-performance workloads requiring low latency and high throughput, where the application layer can handle failures. It is not recommended for workloads demanding high availability or data durability. Example use-cases include caching, temporary data or immutable workloads such as operating system images without local data. * `local-durable`: Local durable storage is similar to local storage but is designed to provide data durability while providing high-performance. It is typically implemented using a redundant storage device or replicated storage solution. Local durable storage is suitable for workloads requiring high performance and low latency, while also ensuring data durability at the cost of availability. The time to restore data may vary depending on the CSP and the will be significantly higher then using `remote-durable` storage. Example use-cases include replicated paxos or raft based databases or replicated databases using synchronous replication, in addition to file storage. * `remote-durable`: Remote storage is a network-attached storage solution designed to provide data redundancy and high availability. While typically slower than local storage, remote storage offers the advantage of being accessible by different hypervisors. This means the storage can be used by different instances running on separate hypervisors, but only one instance at a time. This enabled the recreation of the instance with the same storage on a different hypervisor and therefore greatly reduces the recovery time in case of failure of the hypervisor. Remote storage cannot be attached to multiple instances simultaneously. Example use-cases include file storage or replicated databases using asynchronous replication.
     * 
     */
    private String type;

    private StorageSkuSpec() {}
    /**
     * @return The number of IOPS (Input/Output Operations Per Second) guaranteed for the storage SKU.
     * 
     */
    public Integer iops() {
        return this.iops;
    }
    /**
     * @return Minimum volume size for guaranteed performance, in GB.
     * 
     */
    public Integer minVolumeSize() {
        return this.minVolumeSize;
    }
    /**
     * @return Type of storage SKU. Can be one of the following: * `local-ephemeral`: Local storage is directly attached to the hypervisor hosting the instance. In the event of a hypervisor failure or instance restart, the data may either be lost or become unavailable. The failure mode depends on the Cloud Service Provider (CSP). Users of local storage should be aware of these risks and implement a robust backup strategy or application level replication of the data. Local storage is typically suited for high-performance workloads requiring low latency and high throughput, where the application layer can handle failures. It is not recommended for workloads demanding high availability or data durability. Example use-cases include caching, temporary data or immutable workloads such as operating system images without local data. * `local-durable`: Local durable storage is similar to local storage but is designed to provide data durability while providing high-performance. It is typically implemented using a redundant storage device or replicated storage solution. Local durable storage is suitable for workloads requiring high performance and low latency, while also ensuring data durability at the cost of availability. The time to restore data may vary depending on the CSP and the will be significantly higher then using `remote-durable` storage. Example use-cases include replicated paxos or raft based databases or replicated databases using synchronous replication, in addition to file storage. * `remote-durable`: Remote storage is a network-attached storage solution designed to provide data redundancy and high availability. While typically slower than local storage, remote storage offers the advantage of being accessible by different hypervisors. This means the storage can be used by different instances running on separate hypervisors, but only one instance at a time. This enabled the recreation of the instance with the same storage on a different hypervisor and therefore greatly reduces the recovery time in case of failure of the hypervisor. Remote storage cannot be attached to multiple instances simultaneously. Example use-cases include file storage or replicated databases using asynchronous replication.
     * 
     */
    public String type() {
        return this.type;
    }

    public static Builder builder() {
        return new Builder();
    }

    public static Builder builder(StorageSkuSpec defaults) {
        return new Builder(defaults);
    }
    @CustomType.Builder
    public static final class Builder {
        private Integer iops;
        private Integer minVolumeSize;
        private String type;
        public Builder() {}
        public Builder(StorageSkuSpec defaults) {
    	      Objects.requireNonNull(defaults);
    	      this.iops = defaults.iops;
    	      this.minVolumeSize = defaults.minVolumeSize;
    	      this.type = defaults.type;
        }

        @CustomType.Setter
        public Builder iops(Integer iops) {
            if (iops == null) {
              throw new MissingRequiredPropertyException("StorageSkuSpec", "iops");
            }
            this.iops = iops;
            return this;
        }
        @CustomType.Setter
        public Builder minVolumeSize(Integer minVolumeSize) {
            if (minVolumeSize == null) {
              throw new MissingRequiredPropertyException("StorageSkuSpec", "minVolumeSize");
            }
            this.minVolumeSize = minVolumeSize;
            return this;
        }
        @CustomType.Setter
        public Builder type(String type) {
            if (type == null) {
              throw new MissingRequiredPropertyException("StorageSkuSpec", "type");
            }
            this.type = type;
            return this;
        }
        public StorageSkuSpec build() {
            final var _resultValue = new StorageSkuSpec();
            _resultValue.iops = iops;
            _resultValue.minVolumeSize = minVolumeSize;
            _resultValue.type = type;
            return _resultValue;
        }
    }
}
