// *** WARNING: this file was generated by pulumi-language-java. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.cape.schemas.outputs;

import com.pulumi.core.annotations.CustomType;
import com.pulumi.exceptions.MissingRequiredPropertyException;
import java.lang.String;
import java.util.Objects;
import java.util.Optional;
import javax.annotation.Nullable;

@CustomType
public final class StatusCondition {
    /**
     * @return LastTransitionAt is the last time the condition transitioned from one status to another. This should be when the underlying condition changed. If that is not known, then using the time when the API field changed is acceptable.
     * 
     */
    private String lastTransitionAt;
    /**
     * @return A human-readable message indicating details about the transition.
     * 
     */
    private @Nullable String message;
    /**
     * @return The reason for the condition&#39;s last transition in CamelCase. The specific set of reason values is provider-specific and should be documented by the provider.
     * 
     */
    private @Nullable String reason;
    /**
     * @return Current phase of the resource: - pending: not available, waiting for other resources - creating: not available, creation started - active: available for data layer usage - updating: available for data layer usage - deleting: maybe still available for data layer user, can fail any moment - error: failed to fulfill the request; would be related to provider issue or customer related input.
     * 
     */
    private String state;
    /**
     * @return Type of condition. The condition type is provider-specific and should reflect the specific states relevant to your resource.
     * 
     */
    private @Nullable String type;

    private StatusCondition() {}
    /**
     * @return LastTransitionAt is the last time the condition transitioned from one status to another. This should be when the underlying condition changed. If that is not known, then using the time when the API field changed is acceptable.
     * 
     */
    public String lastTransitionAt() {
        return this.lastTransitionAt;
    }
    /**
     * @return A human-readable message indicating details about the transition.
     * 
     */
    public Optional<String> message() {
        return Optional.ofNullable(this.message);
    }
    /**
     * @return The reason for the condition&#39;s last transition in CamelCase. The specific set of reason values is provider-specific and should be documented by the provider.
     * 
     */
    public Optional<String> reason() {
        return Optional.ofNullable(this.reason);
    }
    /**
     * @return Current phase of the resource: - pending: not available, waiting for other resources - creating: not available, creation started - active: available for data layer usage - updating: available for data layer usage - deleting: maybe still available for data layer user, can fail any moment - error: failed to fulfill the request; would be related to provider issue or customer related input.
     * 
     */
    public String state() {
        return this.state;
    }
    /**
     * @return Type of condition. The condition type is provider-specific and should reflect the specific states relevant to your resource.
     * 
     */
    public Optional<String> type() {
        return Optional.ofNullable(this.type);
    }

    public static Builder builder() {
        return new Builder();
    }

    public static Builder builder(StatusCondition defaults) {
        return new Builder(defaults);
    }
    @CustomType.Builder
    public static final class Builder {
        private String lastTransitionAt;
        private @Nullable String message;
        private @Nullable String reason;
        private String state;
        private @Nullable String type;
        public Builder() {}
        public Builder(StatusCondition defaults) {
    	      Objects.requireNonNull(defaults);
    	      this.lastTransitionAt = defaults.lastTransitionAt;
    	      this.message = defaults.message;
    	      this.reason = defaults.reason;
    	      this.state = defaults.state;
    	      this.type = defaults.type;
        }

        @CustomType.Setter
        public Builder lastTransitionAt(String lastTransitionAt) {
            if (lastTransitionAt == null) {
              throw new MissingRequiredPropertyException("StatusCondition", "lastTransitionAt");
            }
            this.lastTransitionAt = lastTransitionAt;
            return this;
        }
        @CustomType.Setter
        public Builder message(@Nullable String message) {

            this.message = message;
            return this;
        }
        @CustomType.Setter
        public Builder reason(@Nullable String reason) {

            this.reason = reason;
            return this;
        }
        @CustomType.Setter
        public Builder state(String state) {
            if (state == null) {
              throw new MissingRequiredPropertyException("StatusCondition", "state");
            }
            this.state = state;
            return this;
        }
        @CustomType.Setter
        public Builder type(@Nullable String type) {

            this.type = type;
            return this;
        }
        public StatusCondition build() {
            final var _resultValue = new StatusCondition();
            _resultValue.lastTransitionAt = lastTransitionAt;
            _resultValue.message = message;
            _resultValue.reason = reason;
            _resultValue.state = state;
            _resultValue.type = type;
            return _resultValue;
        }
    }
}
